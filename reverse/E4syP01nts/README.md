# E4syP01nts

_Иногда всё, что нужно — внимательный взгляд..._


## Решение

1.     Запускаем нашу программу. Всё, что она делает – выводит сообщение:
![[Pasted image 20250419025014.png]]
и закрывается. Нужно копать глубже – загружаем её в любой дизассемблер (IDA, Ghidra и т.д.).  
Мы попадаем в _start.
Сгенерируем псевдокод (F5) для лучшего понимания:
![[Pasted image 20250419025027.png]]

После вывода строки программа завершает выполнение, но дальше есть цикл, который работает с массивом encfl (encrypted flag) из .rodata.
![[Pasted image 20250419025033.png]]
Этот цикл и есть функция дешифровки флага, хотя она никогда не вызывается.

Цикл выполняется 33 раза (v2 = 33L), и для каждого байта массива выполняются операции:

	·      Вычитание 26;
	
	·      XOR с байтом из key2 по индексу v3 & 3 (т.е. i % 4);
	
	·      то же самое, но на этот раз XOR с байтом из key1;
	
	·      запись обратно в encfl[v3].

![[Pasted image 20250419025134.png]]
Нам нужно проделать то же самое, но правильно написать скрипт.

Python-скрипт:

encfl = [0x61, 0x37, 0x40, 0x93, 0x90, 0x24, 0x2A, 0x5A, 0x6F, 0x39, 0x4F,  
         0x3E, 0x7B, 0x55, 0x41, 0x80, 0x80, 0x71, 0x26, 0x8A, 0x94, 0x31,  
         0x81, 0x81, 0x98, 0x55, 0x59, 0x3E, 0x7F, 0x71, 0x3B, 0x81, 0x88]  
  
key1 = [0xAD, 0xDE, 0xAD, 0xDE] # 0xdeaddead  
key2 = [0xBE, 0xBA, 0xFE, 0xCA] # 0xcafebabe =)  
  
for i in range(len(encfl)):  
    encfl[i] = chr(encfl[i] - 26)  
  
decr = []  
for i in range(len(encfl)):  
    key_idx = i % 4  
    decrypted_value = ord(encfl[i]) ^ key1[key_idx] ^ key2[key_idx]  
    decr.append(chr(decrypted_value))  
  
print(''.join(decr))

2.     Запускаем и получаем флаг:
## Флаг
`TyumenCTF{f0r_tru3_dis4sm_l0v3rs}`