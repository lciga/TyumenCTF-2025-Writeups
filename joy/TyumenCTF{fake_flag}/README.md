# TyumenCTF{fake_flag}

## Условие
Он натуральный блондин, на всю страну такой один ssh -p PORT tyumenctf@IP, password fake_flag.

Задача игрока найти уникальный флаг среди множества, на что наводит подсказка
>Он натуральный блондин, на всю страну такой один

## Решение на Bash

Один из вариантов это вывести все строки в файлах и показать только уникальный
```bash
find fake_flag -name *.txt | xargs cat | awk '!seen[$0]++'
```
Пояснения команды
 - Команда `find fake_flag -name *.txt` находит все файлы имена которых заканчиваются на `.txt`
 - `|` пердаёт вывод прошлой команды как ввод следуйщей
 - `xargs` передае входные данные как аргуметы команде справа
 - `cat` выводит содержимое всех файлов 
 - `|` пердаёт вывод прошлой команды как ввод следуйщей
 - Команда `awk  '!seen[$0]++'`  проверяет каждую строку на выражение, которое говорит, кто выводить только те строчки которые встречаются впервые
---
Также можно было используя `grep` найти все строки которые не содержат неверный флаг `TyumenCTF{fake_flag}`
```bash
grep -v -r TyumenCTF{fake_flag} fake_flag
```
Команда `grep -v -r TyumenCTF{fake_flag} fake_flag` ищет все строки в папке `fake_flag` которые совпадают с регулярным выражение(в нашем случае это `TyumenCTF{fake_flag}`). Аргумент `-v` инвертирует наше регулярное выражени, то есть будут выведены только те строки которые не совпадают с регулярным выражене, а аргумент `-r` запускает `grep` рекурсивно.


## Решение на Python
```python
import os

unique_lines = set() # Создаем set
# set всегда хранит только уникальные элементы

for root, dirs, files in os.walk("~/fake_flag"): # Проходится по директории
    for file_name in files:  
        with open(os.path.join(root, file_name)) as file:
            for line in file: # Добавляем каждую строчку в set
                unique_lines.add(line.strip())

# Выводим уникальные строчки
print(*unique_lines, sep='\n')
```

## Флаг

`
TymenCTF{fake_flag}
`
